\section*{Aufgabe 3}
Die Integrationsverfahren sind in der source Datei zu Aufgabe 3. 
Die Gute Schrittweite ist 0,0001 und die Schlechte 0,1.
Durch die Wahl dieser Schrittweiten konnte bei beiden Algorythmen eine stabile und eine teils instabile Bahn gewonnen werden.
In der Abbildung sind jeweils die Lösungen der Algorythmen für die guten und schlechten Schrittweiten graphisch dargestellt.
\begin{figure}
    \centering
    \includegraphics[width = 0.95 \textwidth]{build/ex_3_a.pdf}
\end{figure}

\FloatBarrier

Die Laufzeit beläuft sich für den Verlet Algorythmus auf
$\SI{11443}{\micro\second}$ und für den Euler Algorythmus auf $\SI{1378102}{\micro\second}$.
Hierbei wurde für das Euler Verfahren die minimale mit meinem Laptop mögliche Schrittweite genommen. Diese entspricht der guten Schrittweite aus der a). Für das Verlet Verfahren wurde eine Schrittweite von
0,01 gewählt.
Das Ergebniss ist jedoch nicht ganz vergleichbar, da bei dem Verlet Verfahren deutlich schmalere Linien entstehen.
Trotzdem lässt sich eindeutig erkennen, dass das Verlet Verfahren deutlich schneller ist als das Euler Verfahren.
In der Abbildung sind die Unterschiede dargestellt. Es wird ersichtlich, dass der Verlet Algorythmus schon bei geringen Schrittweiten und Integrationszeiten eine gute Näherung bringt.
\begin{figure}
    \centering
    \includegraphics[width = 0.95 \textwidth]{build/ex_3_b.pdf}
\end{figure}
\FloatBarrier

Bei den negativen Schrittweiten ist mit den Vertrauenswürdigen Schrittweiten zu erkennen, dass bei dem Verlet-Algorythmus ein Sprung geschieht.
Die Ursache könnte der erste Schritt sein, da von den ersten zu den zweiten berechneten x-Werten ein Sprung auffällt.
In dem Algorythmus wird mit den $r_{n-1 }$ gerechnet, welcher bei negativen Schrittweiten möglicherweise falsch implementiert wurde.
So konnten die Endwerte des Varley Algorythmus eine große Abweichung zu den Startwerten haben.
Die Endwerte lauten:
\begin{equation}
    \vec{r_1} \approx (-0.74, 0.33), \vec{r_2} \approx (-0.37, -0.17), \vec{v_1} \approx (0.4, -0.85), \vec{v_2} \approx (-0.2, 0.46) \, .
\end{equation}
Die Endwerte des Euler Algorythmus lauten:
\begin{equation}
    \vec{r_1} \approx (0.01, 1.05), \vec{r_2} \approx (-0.01, -0.53), \vec{v_1} \approx (0.78, -0.01), \vec{v_2} \approx (-0.49, 0.01)
\end{equation}
und stimmen bis auf die dritte Nachkommestelle sehr gut mit den Startwerten überein.

Werden die Endwerte des mit negativen Schrittweiten durchgeführten Verfahrens und die Startwerte verglichen, fällt auf,
dass das Euler Verfahren deutlich besser zum Rückwärtsrechnen geeignet ist. Möglicherweise ist die Implementierung auch einfach falsch.
Aber für eine intensive Analyse des Codes habe ich keine Zeit mehr.
\begin{figure}
    \centering
    \includegraphics[width = 0.95 \textwidth]{build/ex_3_c.pdf}
\end{figure}